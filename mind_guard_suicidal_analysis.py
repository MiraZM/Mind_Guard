# -*- coding: utf-8 -*-
"""Mind_Guard_Suicidal_Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WBX8x5FPJzk6lPSkPqTvgsk156QQ9fdd

#Loading data
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Load the dataset from the uploaded file
file_path = '/content/drive/MyDrive/MindGuard/data_suicide6k.csv'
df = pd.read_csv(file_path)

"""#Examine the Distribution of Target Labels"""

# Visualize the label distribution
label_counts = df['target'].value_counts()
label_counts.plot(kind='bar')
plt.title('Label Distribution')
plt.xlabel('Label')
plt.ylabel('Frequency')
plt.show()

"""#Preprocess Data"""

import re
import nltk
from nltk.corpus import stopwords
from nltk.stem import WordNetLemmatizer
from transformers import DistilBertTokenizer

nltk.download('stopwords')
nltk.download('wordnet')

from cleantext import clean
def clean_text(text):
    text = text.lower()
    text = re.sub(r'[^\w\s]', ' ', text)
    text = re.sub(r'\d', ' ', text)
    text = clean(text,
                 no_emoji=True,       # remove emojis
                 no_numbers=True)
    return text

df['text'] = df['text'].apply(clean_text)

stop_words = set(stopwords.words('english'))
df['text'] = df['text'].apply(lambda x: ' '.join([word for word in x.split() if word not in stop_words]))

# Lemmatization
lemmatizer = WordNetLemmatizer()
df['text'] = df['text'].apply(lambda x: ' '.join([lemmatizer.lemmatize(word) for word in x.split()]))

# Tokenization using DistilBERT tokenizer
tokenizer = DistilBertTokenizer.from_pretrained('distilbert-base-uncased', do_lower_case=True)
df['tokenized_text'] = df['text'].apply(lambda x: tokenizer.tokenize(x))
df['token_ids'] = df['text'].apply(lambda x: tokenizer.convert_tokens_to_ids(tokenizer.tokenize(x)))

df.head()

"""#Split Dataset Into Training and Validation Sets"""

import torch
import csv
import os
from torch.utils.data import Dataset, DataLoader
from torch.nn.utils.rnn import pad_sequence
from transformers import BertTokenizer, BertForSequenceClassification
from sklearn.model_selection import train_test_split
from tensorflow.keras.losses import sparse_categorical_crossentropy
from torch.optim import AdamW
from torch.optim.lr_scheduler import ExponentialLR
from sklearn.metrics import accuracy_score, precision_recall_fscore_support
from torch.optim.lr_scheduler import StepLR

"""### Dataset Class for Suicidal Sentiment Analysis"""

class SuicidalDataset(Dataset):
    def __init__(self, texts, labels, tokenizer, max_len):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_len = max_len

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = str(self.texts[idx])
        label = self.labels[idx]
        encoding = self.tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_len,
            return_token_type_ids=False,
            return_attention_mask=True,
            padding='max_length',
            truncation=True
        )
        return {
            'input_ids': torch.tensor(encoding['input_ids'], dtype=torch.long),
            'attention_mask': torch.tensor(encoding['attention_mask'], dtype=torch.long),
            'labels': torch.tensor(label, dtype=torch.long)
        }

train_df, val_df = train_test_split(df, test_size=0.4, stratify=df['target'], random_state=42)

# Tokenizer and dataset preparation
tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
max_len = 256
train_dataset = SuicidalDataset(train_df['text'].to_numpy(), train_df['target'].to_numpy(), tokenizer, max_len)
val_dataset = SuicidalDataset(val_df['text'].to_numpy(), val_df['target'].to_numpy(), tokenizer, max_len)

# DataLoader
batch_size = 32
train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
val_dataloader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

#converts all words into vectors
# Model and optimizer
model = BertForSequenceClassification.from_pretrained('bert-base-uncased', num_labels=2)
optimizer = torch.optim.Adam(model.parameters(), lr=1e-5)
scheduler = ExponentialLR(optimizer, gamma=0.95)
scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=5, gamma=0.5)

#CSV file to save the metrics at each epoch
metrics_file = 'training_metrics.csv'

# Header
header = ['Epoch', 'Training Loss', 'Training Accuracy', 'Validation Loss', 'Validation Accuracy', 'Precision', 'Recall', 'F1 Score']

with open(metrics_file, 'w', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=header)
    writer.writeheader()

epoch_metrics = {'Epoch': 1, 'Training Loss': 0.1, 'Training Accuracy': 0.9,
                 'Validation Loss': 0.05, 'Validation Accuracy': 0.95,
                 'Precision': 0.92, 'Recall': 0.88, 'F1 Score': 0.90}

with open(metrics_file, 'a', newline='') as file:
    writer = csv.DictWriter(file, fieldnames=header)
    writer.writerow(epoch_metrics)

def calculate_metrics(preds, labels):
    preds = np.argmax(preds, axis=1)
    accuracy = accuracy_score(labels, preds)
    precision, recall, f1, _ = precision_recall_fscore_support(labels, preds, average='binary', zero_division=0)
    return accuracy, precision, recall, f1

"""#Training Model
## Heads Up: Take in mind that this training was done on pretrained model of our own so we only trained it on 5 more epoches
"""

# Initialize metrics file
metrics_file = 'training_metrics.csv'
with open(metrics_file, 'w', newline='') as file:
    writer = csv.writer(file)
    writer.writerow(['Epoch', 'Training Loss', 'Training Accuracy', 'Validation Loss', 'Validation Accuracy', 'Precision', 'Recall', 'F1 Score'])

# Function to calculate metrics
def calculate_metrics(preds, labels):
    preds = np.argmax(preds, axis=1)
    accuracy = accuracy_score(labels, preds)
    precision, recall, f1, _ = precision_recall_fscore_support(labels, preds, average='binary', zero_division=0 )
    return accuracy, precision, recall, f1

# Training loop
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
model.to(device)
epochs = 5


for epoch in range(epochs):
    model.train()
    total_loss, total_accuracy = 0, 0

    for batch in train_dataloader:
        input_ids = batch['input_ids'].to(device)
        attention_mask = batch['attention_mask'].to(device)
        labels = batch['labels'].to(device)

        outputs = model(input_ids, attention_mask=attention_mask, labels=labels)
        loss = outputs.loss

        optimizer.zero_grad()
        loss.backward()
        torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)  # Gradient clipping
        optimizer.step()

        total_loss += loss.item()
        logits = outputs.logits.detach().cpu().numpy()
        label_ids = labels.to('cpu').numpy()
        temp_accuracy, _, _, _ = calculate_metrics(logits, label_ids)
        total_accuracy += temp_accuracy

    avg_train_loss = total_loss / len(train_dataloader)
    avg_train_accuracy = total_accuracy / len(train_dataloader)
    print(f"Epoch {epoch + 1}/{epochs}, Training Loss: {avg_train_loss}, Training Accuracy: {avg_train_accuracy}")

    # Validation
    model.eval()
    total_val_loss, total_val_accuracy, total_precision, total_recall, total_f1 = 0, 0, 0, 0, 0

    with torch.no_grad():
        for batch in val_dataloader:
            input_ids = batch['input_ids'].to(device)
            attention_mask = batch['attention_mask'].to(device)
            labels = batch['labels'].to(device)

            outputs = model(input_ids, attention_mask=attention_mask, labels=labels)
            val_loss = outputs.loss
            total_val_loss += val_loss.item()
            logits = outputs.logits.detach().cpu().numpy()
            label_ids = labels.to('cpu').numpy()
            temp_accuracy, temp_precision, temp_recall, temp_f1 = calculate_metrics(logits, label_ids)
            total_val_accuracy += temp_accuracy
            total_precision += temp_precision
            total_recall += temp_recall
            total_f1 += temp_f1

    avg_val_accuracy = total_val_accuracy / len(val_dataloader)
    avg_precision = total_precision / len(val_dataloader)
    avg_recall = total_recall / len(val_dataloader)
    avg_f1 = total_f1 / len(val_dataloader)
    avg_val_loss = total_val_loss / len(val_dataloader)
    print(f"Epoch {epoch + 1}/{epochs}, Validation Loss: {avg_val_loss}, Validation Accuracy: {avg_val_accuracy}, Precision: {avg_precision}, Recall: {avg_recall}, F1 Score: {avg_f1}")

    # Save metrics to CSV
    with open(metrics_file, 'a', newline='') as file:
        writer = csv.writer(file)
        writer.writerow([epoch + 1, avg_train_loss, avg_train_accuracy, avg_val_loss, avg_val_accuracy, avg_precision, avg_recall, avg_f1])

    # Adjust learning rate
    scheduler.step()

"""###Saving and Loading"""

# Save the model
model_save_path = "/content/drive/MyDrive/MindGuard/the_new_model.pt"
torch.save(model.state_dict(), model_save_path)

# Define device
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Load the pretrained model
model = BertForSequenceClassification.from_pretrained('bert-base-uncased', num_labels=2)
model.load_state_dict(torch.load("/content/drive/MyDrive/MindGuard/The_Golden.pt"))
model= model.to(device)

"""#Testing and Predicting"""

def predict_and_save(text, model, tokenizer, max_len, file_path):
    model.eval()
    inputs = tokenizer.encode_plus(
        text,
        add_special_tokens=True,
        max_length=max_len,
        return_token_type_ids=False,
        return_attention_mask=True,
        padding='max_length',
        truncation=True,
        return_tensors='pt'
    )

    with torch.no_grad():
        outputs = model(**inputs.to(model.device))
        prediction = torch.argmax(outputs.logits, dim=1).item()

    # Append the text and prediction to the CSV file
    with open(file_path, 'a', newline='', encoding='utf-8') as file:
        writer = csv.writer(file)
        writer.writerow([text, prediction])

    return prediction

# File path for the CSV
csv_file_path = 'predictions.csv'

# Example usage
sample_text = "I want to die "
prediction = predict_and_save(sample_text, model, tokenizer, max_len=256, file_path=csv_file_path)
print("Prediction:", prediction)

"""#More testing Examples

![image.png](data:image/png;base64,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)

#HyperTuning
"""

def create_dataloaders(train_df, val_df, batch_size, tokenizer, max_len):
    # Convert DataFrame into SuicidalDataset
    train_dataset = SuicidalDataset(train_df['text'].to_numpy(), train_df['target'].to_numpy(), tokenizer, max_len)
    val_dataset = SuicidalDataset(val_df['text'].to_numpy(), val_df['target'].to_numpy(), tokenizer, max_len)

    # Create DataLoaders
    train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_dataloader = DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    return train_dataloader, val_dataloader

def train_and_evaluate(model, train_dataloader, val_dataloader, optimizer, epochs, device):
    best_val_accuracy = 0.0
    model.to(device)

    for epoch in range(epochs):
        # Training phase
        model.train()
        total_train_loss = 0
        for batch in train_dataloader:
            input_ids = batch['input_ids'].to(device)
            attention_mask = batch['attention_mask'].to(device)
            labels = batch['labels'].to(device)

            optimizer.zero_grad()
            outputs = model(input_ids, attention_mask, labels=labels)
            loss = outputs.loss
            total_train_loss += loss.item()
            loss.backward()
            optimizer.step()

        avg_train_loss = total_train_loss / len(train_dataloader)

        # Validation phase
        model.eval()
        total_val_accuracy = 0
        total_val_loss = 0
        for batch in val_dataloader:
            input_ids = batch['input_ids'].to(device)
            attention_mask = batch['attention_mask'].to(device)
            labels = batch['labels'].to(device)

            with torch.no_grad():
                outputs = model(input_ids, attention_mask, labels=labels)
                loss = outputs.loss
                logits = outputs.logits
                total_val_loss += loss.item()

            logits = logits.detach().cpu().numpy()
            label_ids = labels.to('cpu').numpy()
            preds = np.argmax(logits, axis=1)
            total_val_accuracy += accuracy_score(label_ids, preds)

        avg_val_loss = total_val_loss / len(val_dataloader)
        avg_val_accuracy = total_val_accuracy / len(val_dataloader)

        print(f"Epoch {epoch + 1}/{epochs} - Train Loss: {avg_train_loss:.2f}, Val Loss: {avg_val_loss:.2f}, Val Accuracy: {avg_val_accuracy:.2f}")

        # Update best model if current accuracy is better
        if avg_val_accuracy > best_val_accuracy:
            best_val_accuracy = avg_val_accuracy
            # Optionally save the best model state
            torch.save(model.state_dict(), 'best_model_state.bin')

    return best_val_accuracy

# Hyperparameter ranges
learning_rates = [5e-5, 3e-5, 2e-5]
batch_sizes = [16, 32]
num_epochs = [3, 4, 5]

best_accuracy = 0
best_params = {}
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

for lr in learning_rates:
    for batch_size in batch_sizes:
        for epochs in num_epochs:
            # Update dataloaders if batch_size changes
            train_dataloader, val_dataloader = create_dataloaders(train_df, val_df, batch_size, tokenizer, max_len)

            # Initialize model and optimizer with current set of hyperparameters
            model = BertForSequenceClassification.from_pretrained('bert-base-uncased', num_labels=2)
            optimizer = AdamW(model.parameters(), lr=lr)

            # Train and evaluate the model
            accuracy = train_and_evaluate(model, train_dataloader, val_dataloader, optimizer, epochs, device)

            # Update best parameters if current model is better
            if accuracy > best_accuracy:
                best_accuracy = accuracy
                best_params = {'lr': lr, 'batch_size': batch_size, 'epochs': epochs}

print("Best Hyperparameters:", best_params)
print("Best Accuracy:", best_accuracy)